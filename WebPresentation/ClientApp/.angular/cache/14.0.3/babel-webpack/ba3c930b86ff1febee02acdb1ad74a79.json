{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport { neverReached as n } from \"../../../../../../core/compilerUtils.js\";\nimport { EvaluateAmbientLighting as i } from \"./EvaluateAmbientLighting.glsl.js\";\nimport { EvaluateAmbientOcclusion as e } from \"./EvaluateAmbientOcclusion.glsl.js\";\nimport { addMainLightDirection as o, addMainLightIntensity as t, MainLighting as a } from \"./MainLighting.glsl.js\";\nimport { PhysicallyBasedRendering as r } from \"./PhysicallyBasedRendering.glsl.js\";\nimport { PBRMode as l } from \"./PhysicallyBasedRenderingParameters.glsl.js\";\nimport { PiUtils as c } from \"./PiUtils.glsl.js\";\nimport { BooleanPassUniform as d } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { FloatPassUniform as s } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as m } from \"../../shaderModules/interfaces.js\";\nimport { ambientBoost as g } from \"../../../lighting/SceneLighting.js\";\n\nfunction h(n) {\n  n.constants.add(\"ambientBoostFactor\", \"float\", g);\n}\n\nfunction u(n) {\n  n.uniforms.add(new s(\"lightingGlobalFactor\", (n, i) => i.lighting.globalFactor));\n}\n\nfunction p(g, p) {\n  const v = g.fragment;\n\n  switch (g.include(e, p), p.pbrMode !== l.Disabled && g.include(r, p), g.include(i, p), g.include(c), v.code.add(m`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${p.pbrMode === l.Disabled ? \"\" : \"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `), h(v), u(v), o(v), v.code.add(m`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${p.spherical ? m`normalize(vPosWorld)` : m`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `), t(v), v.code.add(m`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}`), p.pbrMode) {\n    case l.Disabled:\n    case l.WaterOnIntegratedMesh:\n    case l.Water:\n      g.include(a, p), v.code.add(m`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`);\n      break;\n\n    case l.Normal:\n    case l.Schematic:\n      v.code.add(m`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v.code.add(m`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p.useFillLights ? v.uniforms.add(new d(\"hasFillLights\", (n, i) => i.enableFillLights)) : v.constants.add(\"hasFillLights\", \"bool\", !1), v.code.add(m`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v.uniforms.add([new s(\"lightingSpecularStrength\", (n, i) => i.lighting.mainLight.specularStrength), new s(\"lightingEnvironmentStrength\", (n, i) => i.lighting.mainLight.environmentStrength)]), v.code.add(m`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v.code.add(m`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${p.pbrMode === l.Schematic ? m`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : m`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `);\n      break;\n\n    case l.Terrain:\n    case l.TerrainWithWater:\n      g.include(a, p), v.code.add(m`const float roughnessTerrain = 0.5;\nconst float specularityTerrain = 0.5;\nconst vec3 fresnelReflectionTerrain = vec3(0.04);\nvec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {\nvec3 viewDirection = -vd;\nvec3 h = normalize(viewDirection + mainLightDirection);\nfloat NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);\nfloat NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);\nfloat NdotH = clamp(dot(n, h), 0.0, 1.0);\nfloat NdotNG = clamp(dot(n, nup), -1.0, 1.0);\nvec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));\nfloat lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];\nvec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;\nvec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));\nvec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;\nvec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;\nvec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;\nvec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;\nvec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;\nvec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);\nvec3 specularColor = f0 * dfg.x + f90 * dfg.y;\nvec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;\nvec3 outColorLinear = outDiffColor + specularComponent;\nvec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));\nreturn outColor;\n}`);\n      break;\n\n    default:\n      n(p.pbrMode);\n\n    case l.COUNT:\n  }\n}\n\nexport { p as EvaluateSceneLighting, h as addAmbientBoostFactor, u as addLightingGlobalFactor };","map":{"version":3,"names":["neverReached","n","EvaluateAmbientLighting","i","EvaluateAmbientOcclusion","e","addMainLightDirection","o","addMainLightIntensity","t","MainLighting","a","PhysicallyBasedRendering","r","PBRMode","l","PiUtils","c","BooleanPassUniform","d","FloatPassUniform","s","glsl","m","ambientBoost","g","h","constants","add","u","uniforms","lighting","globalFactor","p","v","fragment","include","pbrMode","Disabled","code","spherical","WaterOnIntegratedMesh","Water","Normal","Schematic","useFillLights","enableFillLights","mainLight","specularStrength","environmentStrength","Terrain","TerrainWithWater","COUNT","EvaluateSceneLighting","addAmbientBoostFactor","addLightingGlobalFactor"],"sources":["C:/Users/akaps/Documents/Visual Studio 2022/Projects/MT_LRS/WebPresentation/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.26/esri/copyright.txt for details.\n*/\nimport{neverReached as n}from\"../../../../../../core/compilerUtils.js\";import{EvaluateAmbientLighting as i}from\"./EvaluateAmbientLighting.glsl.js\";import{EvaluateAmbientOcclusion as e}from\"./EvaluateAmbientOcclusion.glsl.js\";import{addMainLightDirection as o,addMainLightIntensity as t,MainLighting as a}from\"./MainLighting.glsl.js\";import{PhysicallyBasedRendering as r}from\"./PhysicallyBasedRendering.glsl.js\";import{PBRMode as l}from\"./PhysicallyBasedRenderingParameters.glsl.js\";import{PiUtils as c}from\"./PiUtils.glsl.js\";import{BooleanPassUniform as d}from\"../../shaderModules/BooleanPassUniform.js\";import{FloatPassUniform as s}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as m}from\"../../shaderModules/interfaces.js\";import{ambientBoost as g}from\"../../../lighting/SceneLighting.js\";function h(n){n.constants.add(\"ambientBoostFactor\",\"float\",g)}function u(n){n.uniforms.add(new s(\"lightingGlobalFactor\",((n,i)=>i.lighting.globalFactor)))}function p(g,p){const v=g.fragment;switch(g.include(e,p),p.pbrMode!==l.Disabled&&g.include(r,p),g.include(i,p),g.include(c),v.code.add(m`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${p.pbrMode===l.Disabled?\"\":\"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `),h(v),u(v),o(v),v.code.add(m`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${p.spherical?m`normalize(vPosWorld)`:m`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `),t(v),v.code.add(m`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}`),p.pbrMode){case l.Disabled:case l.WaterOnIntegratedMesh:case l.Water:g.include(a,p),v.code.add(m`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`);break;case l.Normal:case l.Schematic:v.code.add(m`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),v.code.add(m`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),p.useFillLights?v.uniforms.add(new d(\"hasFillLights\",((n,i)=>i.enableFillLights))):v.constants.add(\"hasFillLights\",\"bool\",!1),v.code.add(m`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),v.uniforms.add([new s(\"lightingSpecularStrength\",((n,i)=>i.lighting.mainLight.specularStrength)),new s(\"lightingEnvironmentStrength\",((n,i)=>i.lighting.mainLight.environmentStrength))]),v.code.add(m`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`),v.code.add(m`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${p.pbrMode===l.Schematic?m`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`:m`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `);break;case l.Terrain:case l.TerrainWithWater:g.include(a,p),v.code.add(m`const float roughnessTerrain = 0.5;\nconst float specularityTerrain = 0.5;\nconst vec3 fresnelReflectionTerrain = vec3(0.04);\nvec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {\nvec3 viewDirection = -vd;\nvec3 h = normalize(viewDirection + mainLightDirection);\nfloat NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);\nfloat NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);\nfloat NdotH = clamp(dot(n, h), 0.0, 1.0);\nfloat NdotNG = clamp(dot(n, nup), -1.0, 1.0);\nvec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));\nfloat lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];\nvec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;\nvec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));\nvec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;\nvec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;\nvec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;\nvec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;\nvec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;\nvec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);\nvec3 specularColor = f0 * dfg.x + f90 * dfg.y;\nvec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;\nvec3 outColorLinear = outDiffColor + specularComponent;\nvec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));\nreturn outColor;\n}`);break;default:n(p.pbrMode);case l.COUNT:}}export{p as EvaluateSceneLighting,h as addAmbientBoostFactor,u as addLightingGlobalFactor};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
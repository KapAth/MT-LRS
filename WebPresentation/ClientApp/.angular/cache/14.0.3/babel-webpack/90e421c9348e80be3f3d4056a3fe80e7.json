{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/akaps/Documents/Visual Studio 2022/Projects/MT_LRS/WebPresentation/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.7\n */\nimport { Build } from '@stencil/core/internal/client/index.js';\nimport { c as getElementDir, r as closestElementCrossShadowBoundary } from './dom.js';\nimport { d as debounce } from './debounce.js';\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\n\nconst computePosition$1 = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (reference, floating, config) {\n    const {\n      placement = 'bottom',\n      strategy = 'absolute',\n      middleware = [],\n      platform\n    } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = yield platform.isRTL == null ? void 0 : platform.isRTL(floating);\n    let rects = yield platform.getElementRects({\n      reference,\n      floating,\n      strategy\n    });\n    let {\n      x,\n      y\n    } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n\n    for (let i = 0; i < validMiddleware.length; i++) {\n      const {\n        name,\n        fn\n      } = validMiddleware[i];\n      const {\n        x: nextX,\n        y: nextY,\n        data,\n        reset\n      } = yield fn({\n        x,\n        y,\n        initialPlacement: placement,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData,\n        rects,\n        platform,\n        elements: {\n          reference,\n          floating\n        }\n      });\n      x = nextX != null ? nextX : x;\n      y = nextY != null ? nextY : y;\n      middlewareData = { ...middlewareData,\n        [name]: { ...middlewareData[name],\n          ...data\n        }\n      };\n\n      if (reset && resetCount <= 50) {\n        resetCount++;\n\n        if (typeof reset === 'object') {\n          if (reset.placement) {\n            statefulPlacement = reset.placement;\n          }\n\n          if (reset.rects) {\n            rects = reset.rects === true ? yield platform.getElementRects({\n              reference,\n              floating,\n              strategy\n            }) : reset.rects;\n          }\n\n          ({\n            x,\n            y\n          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n        }\n\n        i = -1;\n        continue;\n      }\n    }\n\n    return {\n      x,\n      y,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData\n    };\n  });\n\n  return function computePosition$1(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\n\n\nfunction detectOverflow(_x4, _x5) {\n  return _detectOverflow.apply(this, arguments);\n}\n\nfunction _detectOverflow() {\n  _detectOverflow = _asyncToGenerator(function* (middlewareArguments, options) {\n    var _await$platform$isEle;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    const {\n      x,\n      y,\n      platform,\n      rects,\n      elements,\n      strategy\n    } = middlewareArguments;\n    const {\n      boundary = 'clippingAncestors',\n      rootBoundary = 'viewport',\n      elementContext = 'floating',\n      altBoundary = false,\n      padding = 0\n    } = options;\n    const paddingObject = getSideObjectFromPadding(padding);\n    const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(yield platform.getClippingRect({\n      element: ((_await$platform$isEle = yield platform.isElement == null ? void 0 : platform.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n      boundary,\n      rootBoundary,\n      strategy\n    }));\n    const rect = elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference;\n    const offsetParent = yield platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n    const offsetScale = (yield platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? (yield platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    };\n    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n      rect,\n      offsetParent,\n      strategy\n    }) : rect);\n    return {\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n  });\n  return _detectOverflow.apply(this, arguments);\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\n\n\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  fn(middlewareArguments) {\n    return _asyncToGenerator(function* () {\n      // Since `element` is required, we don't Partial<> the type\n      const {\n        element,\n        padding = 0\n      } = options != null ? options : {};\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        platform\n      } = middlewareArguments;\n\n      if (element == null) {\n        return {};\n      }\n\n      const paddingObject = getSideObjectFromPadding(padding);\n      const coords = {\n        x,\n        y\n      };\n      const axis = getMainAxisFromPlacement(placement);\n      const length = getLengthFromAxis(axis);\n      const arrowDimensions = yield platform.getDimensions(element);\n      const minProp = axis === 'y' ? 'top' : 'left';\n      const maxProp = axis === 'y' ? 'bottom' : 'right';\n      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n      const startDiff = coords[axis] - rects.reference[axis];\n      const arrowOffsetParent = yield platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);\n      let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n      if (clientSize === 0) {\n        clientSize = rects.floating[length];\n      }\n\n      const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n      // point is outside the floating element's bounds\n\n      const min = paddingObject[minProp];\n      const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n      const offset = within(min, center, max); // If the reference is small enough that the arrow's padding causes it to\n      // to point to nothing for an aligned placement, adjust the offset of the\n      // floating element itself. This stops `shift()` from taking action, but can\n      // be worked around by calling it again after the `arrow()` if desired.\n\n      const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n      const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n      return {\n        [axis]: coords[axis] - alignmentOffset,\n        data: {\n          [axis]: offset,\n          centerOffset: center - offset\n        }\n      };\n    })();\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\n\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\n\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\n\n\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    fn(middlewareArguments) {\n      return _asyncToGenerator(function* () {\n        var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n        const {\n          x,\n          y,\n          rects,\n          middlewareData,\n          placement,\n          platform,\n          elements\n        } = middlewareArguments;\n        const {\n          alignment,\n          allowedPlacements = allPlacements,\n          autoAlignment = true,\n          ...detectOverflowOptions\n        } = options;\n        const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n        const overflow = yield detectOverflow(middlewareArguments, detectOverflowOptions);\n        const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n        const currentPlacement = placements[currentIndex];\n\n        if (currentPlacement == null) {\n          return {};\n        }\n\n        const {\n          main,\n          cross\n        } = getAlignmentSides(currentPlacement, rects, yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)); // Make `computeCoords` start from the right place\n\n        if (placement !== currentPlacement) {\n          return {\n            x,\n            y,\n            reset: {\n              placement: placements[0]\n            }\n          };\n        }\n\n        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n        const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n          placement: currentPlacement,\n          overflows: currentOverflows\n        }];\n        const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n        if (nextPlacement) {\n          return {\n            data: {\n              index: currentIndex + 1,\n              overflows: allOverflows\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n        const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n          let {\n            overflows\n          } = _ref;\n          return overflows.every(overflow => overflow <= 0);\n        })) == null ? void 0 : _placementsSortedByLe.placement;\n        const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n        if (resetPlacement !== placement) {\n          return {\n            data: {\n              index: currentIndex + 1,\n              overflows: allOverflows\n            },\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n\n        return {};\n      })();\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\n\n\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    fn(middlewareArguments) {\n      return _asyncToGenerator(function* () {\n        var _middlewareData$flip;\n\n        const {\n          placement,\n          middlewareData,\n          rects,\n          initialPlacement,\n          platform,\n          elements\n        } = middlewareArguments;\n        const {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = 'bestFit',\n          flipAlignment = true,\n          ...detectOverflowOptions\n        } = options;\n        const side = getSide(placement);\n        const isBasePlacement = side === initialPlacement;\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        const placements = [initialPlacement, ...fallbackPlacements];\n        const overflow = yield detectOverflow(middlewareArguments, detectOverflowOptions);\n        const overflows = [];\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n        if (checkMainAxis) {\n          overflows.push(overflow[side]);\n        }\n\n        if (checkCrossAxis) {\n          const {\n            main,\n            cross\n          } = getAlignmentSides(placement, rects, yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n          overflows.push(overflow[main], overflow[cross]);\n        }\n\n        overflowsData = [...overflowsData, {\n          placement,\n          overflows\n        }]; // One or more sides is overflowing\n\n        if (!overflows.every(side => side <= 0)) {\n          var _middlewareData$flip$, _middlewareData$flip2;\n\n          const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n          const nextPlacement = placements[nextIndex];\n\n          if (nextPlacement) {\n            // Try next placement and re-run the lifecycle\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n\n          let resetPlacement = 'bottom';\n\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n                if (placement) {\n                  resetPlacement = placement;\n                }\n\n                break;\n              }\n\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n\n          if (placement !== resetPlacement) {\n            return {\n              reset: {\n                placement: resetPlacement\n              }\n            };\n          }\n        }\n\n        return {};\n      })();\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\n\n\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'hide',\n    options,\n\n    fn(middlewareArguments) {\n      return _asyncToGenerator(function* () {\n        const {\n          strategy = 'referenceHidden',\n          ...detectOverflowOptions\n        } = options;\n        const {\n          rects\n        } = middlewareArguments;\n\n        switch (strategy) {\n          case 'referenceHidden':\n            {\n              const overflow = yield detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n                elementContext: 'reference'\n              });\n              const offsets = getSideOffsets(overflow, rects.reference);\n              return {\n                data: {\n                  referenceHiddenOffsets: offsets,\n                  referenceHidden: isAnySideFullyClipped(offsets)\n                }\n              };\n            }\n\n          case 'escaped':\n            {\n              const overflow = yield detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n                altBoundary: true\n              });\n              const offsets = getSideOffsets(overflow, rects.floating);\n              return {\n                data: {\n                  escapedOffsets: offsets,\n                  escaped: isAnySideFullyClipped(offsets)\n                }\n              };\n            }\n\n          default:\n            {\n              return {};\n            }\n        }\n      })();\n    }\n\n  };\n};\n\nfunction convertValueToCoords(_x6, _x7) {\n  return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\n\nfunction _convertValueToCoords() {\n  _convertValueToCoords = _asyncToGenerator(function* (middlewareArguments, value) {\n    const {\n      placement,\n      platform,\n      elements\n    } = middlewareArguments;\n    const rtl = yield platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n    const side = getSide(placement);\n    const alignment = getAlignment(placement);\n    const isVertical = getMainAxisFromPlacement(placement) === 'x';\n    const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n    let {\n      mainAxis,\n      crossAxis,\n      alignmentAxis\n    } = typeof rawValue === 'number' ? {\n      mainAxis: rawValue,\n      crossAxis: 0,\n      alignmentAxis: null\n    } : {\n      mainAxis: 0,\n      crossAxis: 0,\n      alignmentAxis: null,\n      ...rawValue\n    };\n\n    if (alignment && typeof alignmentAxis === 'number') {\n      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n    }\n\n    return isVertical ? {\n      x: crossAxis * crossAxisMulti,\n      y: mainAxis * mainAxisMulti\n    } : {\n      x: mainAxis * mainAxisMulti,\n      y: crossAxis * crossAxisMulti\n    };\n  });\n  return _convertValueToCoords.apply(this, arguments);\n}\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    fn(middlewareArguments) {\n      return _asyncToGenerator(function* () {\n        const {\n          x,\n          y\n        } = middlewareArguments;\n        const diffCoords = yield convertValueToCoords(middlewareArguments, value);\n        return {\n          x: x + diffCoords.x,\n          y: y + diffCoords.y,\n          data: diffCoords\n        };\n      })();\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\n\n\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    fn(middlewareArguments) {\n      return _asyncToGenerator(function* () {\n        const {\n          x,\n          y,\n          placement\n        } = middlewareArguments;\n        const {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: _ref => {\n              let {\n                x,\n                y\n              } = _ref;\n              return {\n                x,\n                y\n              };\n            }\n          },\n          ...detectOverflowOptions\n        } = options;\n        const coords = {\n          x,\n          y\n        };\n        const overflow = yield detectOverflow(middlewareArguments, detectOverflowOptions);\n        const mainAxis = getMainAxisFromPlacement(getSide(placement));\n        const crossAxis = getCrossAxis(mainAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n\n        if (checkMainAxis) {\n          const minSide = mainAxis === 'y' ? 'top' : 'left';\n          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n          const min = mainAxisCoord + overflow[minSide];\n          const max = mainAxisCoord - overflow[maxSide];\n          mainAxisCoord = within(min, mainAxisCoord, max);\n        }\n\n        if (checkCrossAxis) {\n          const minSide = crossAxis === 'y' ? 'top' : 'left';\n          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n          const min = crossAxisCoord + overflow[minSide];\n          const max = crossAxisCoord - overflow[maxSide];\n          crossAxisCoord = within(min, crossAxisCoord, max);\n        }\n\n        const limitedCoords = limiter.fn({ ...middlewareArguments,\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        });\n        return { ...limitedCoords,\n          data: {\n            x: limitedCoords.x - x,\n            y: limitedCoords.y - y\n          }\n        };\n      })();\n    }\n\n  };\n};\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\n\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n\n  const uaData = navigator.userAgentData;\n\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\n\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\n\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\n\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter; // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some( // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const offsetWidth = element.offsetWidth;\n  const offsetHeight = element.offsetHeight;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height; // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  const result = // Step into the shadow DOM of the parent of a slotted node\n  node.assignedSlot || // DOM Element detected\n  node.parentNode || ( // ShadowRoot detected\n  isShadowRoot(node) ? node.host : null) || // Fallback\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n} // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n} // Returns the inner client rect, subtracting scrollbars if present\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n    width,\n    height\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  if (clippingAncestor === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingAncestor)) {\n    return getInnerBoundingClientRect(clippingAncestor, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\n\n\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element; // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n\n    currentNode = getParentNode(currentNode);\n  }\n\n  cache.set(element, result);\n  return result;\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n\n  getElementRects(_ref) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let {\n        reference,\n        floating,\n        strategy\n      } = _ref;\n      const getOffsetParentFn = _this.getOffsetParent || getOffsetParent;\n      const getDimensionsFn = _this.getDimensions;\n      return {\n        reference: getRectRelativeToOffsetParent(reference, yield getOffsetParentFn(floating), strategy),\n        floating: {\n          x: 0,\n          y: 0,\n          ...(yield getDimensionsFn(floating))\n        }\n      };\n    })();\n  },\n\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\n\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\n\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = { ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, { ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n/**\n * This module helps users provide custom configuration for component internals.\n *\n * @internal\n */\n\n\nconst configOverrides = globalThis[\"calciteComponentsConfig\"];\nconst config = {\n  /**\n   * We apply a custom fix to improve positioning for non-Chromium browsers.\n   * The fix comes at a performance cost, so provides users a way to opt-out if necessary.\n   *\n   * @internal\n   */\n  floatingUINonChromiumPositioningFix: true,\n  ...configOverrides\n};\nconst floatingUIBrowserCheck = patchFloatingUiForNonChromiumBrowsers();\n\nfunction patchFloatingUiForNonChromiumBrowsers() {\n  return _patchFloatingUiForNonChromiumBrowsers.apply(this, arguments);\n}\n/**\n * Exported for testing purposes only\n */\n\n\nfunction _patchFloatingUiForNonChromiumBrowsers() {\n  _patchFloatingUiForNonChromiumBrowsers = _asyncToGenerator(function* () {\n    function getUAString() {\n      const uaData = navigator.userAgentData;\n\n      if (uaData?.brands) {\n        return uaData.brands.map(item => `${item.brand}/${item.version}`).join(\" \");\n      }\n\n      return navigator.userAgent;\n    }\n\n    if (Build.isBrowser && config.floatingUINonChromiumPositioningFix && // ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\n    /firefox|safari/i.test(getUAString())) {\n      const {\n        getClippingRect,\n        getElementRects,\n        getOffsetParent\n      } = yield import('./nonChromiumPlatformUtils.js');\n      platform.getClippingRect = getClippingRect;\n      platform.getOffsetParent = getOffsetParent;\n      platform.getElementRects = getElementRects;\n    }\n  });\n  return _patchFloatingUiForNonChromiumBrowsers.apply(this, arguments);\n}\n\nconst placementDataAttribute = \"data-placement\";\n/**\n * Exported for testing purposes only\n */\n\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\"top\", \"bottom\", \"right\", \"left\", \"top-start\", \"top-end\", \"bottom-start\", \"bottom-end\", \"right-start\", \"right-end\", \"left-start\", \"left-end\"];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\"\n};\n\nfunction getMiddleware({\n  placement,\n  flipDisabled,\n  flipPlacements,\n  offsetDistance,\n  offsetSkidding,\n  arrowEl,\n  type\n}) {\n  const defaultMiddleware = [shift(), hide()];\n\n  if (type === \"menu\") {\n    return [...defaultMiddleware, flip({\n      fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"]\n    })];\n  }\n\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [...defaultMiddleware, offset({\n      mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n      crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0\n    })];\n\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({\n        alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null\n      }));\n    } else if (!flipDisabled) {\n      middleware.push(flip(flipPlacements ? {\n        fallbackPlacements: flipPlacements\n      } : {}));\n    }\n\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl\n      }));\n    }\n\n    return middleware;\n  }\n\n  return [];\n}\n\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter(placement => effectivePlacements.includes(placement));\n\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements.map(placement => `\"${placement}\"`).join(\", \").trim()}`, {\n      el\n    });\n  }\n\n  return filteredPlacements;\n}\n\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n\n  return placement.replace(/leading/gi, placements[0]).replace(/trailing/gi, placements[1]);\n}\n/**\n * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.\n *\n * Note: this is not needed for components that use `calcite-popover`.\n *\n * @param component\n * @param options\n * @param options.referenceEl\n * @param options.floatingEl\n * @param options.overlayPositioning\n * @param options.placement\n * @param options.flipDisabled\n * @param options.flipPlacements\n * @param options.offsetDistance\n * @param options.offsetSkidding\n * @param options.arrowEl\n * @param options.type\n * @param delayed\n */\n\n\nfunction reposition(_x8, _x9) {\n  return _reposition.apply(this, arguments);\n}\n\nfunction _reposition() {\n  _reposition = _asyncToGenerator(function* (component, options, delayed = false) {\n    if (!component.open) {\n      return;\n    }\n\n    return delayed ? debouncedReposition(options) : positionFloatingUI(options);\n  });\n  return _reposition.apply(this, arguments);\n}\n\nconst debouncedReposition = debounce(positionFloatingUI, repositionDebounceTimeout, {\n  leading: true,\n  maxWait: repositionDebounceTimeout\n});\n/**\n * Positions the floating element relative to the reference element.\n *\n * **Note:** exported for testing purposes only\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.flipDisabled\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n * @param root0.includeArrow\n */\n\nfunction positionFloatingUI(_x10) {\n  return _positionFloatingUI.apply(this, arguments);\n}\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\n\n\nfunction _positionFloatingUI() {\n  _positionFloatingUI = _asyncToGenerator(function* ({\n    referenceEl,\n    floatingEl,\n    overlayPositioning = \"absolute\",\n    placement,\n    flipDisabled,\n    flipPlacements,\n    offsetDistance,\n    offsetSkidding,\n    includeArrow = false,\n    arrowEl,\n    type\n  }) {\n    if (!referenceEl || !floatingEl || includeArrow && !arrowEl) {\n      return null;\n    }\n\n    yield floatingUIBrowserCheck;\n    const {\n      x,\n      y,\n      placement: effectivePlacement,\n      strategy: position,\n      middlewareData\n    } = yield computePosition(referenceEl, floatingEl, {\n      strategy: overlayPositioning,\n      placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\" ? undefined : getEffectivePlacement(floatingEl, placement),\n      middleware: getMiddleware({\n        placement,\n        flipDisabled,\n        flipPlacements,\n        offsetDistance,\n        offsetSkidding,\n        arrowEl,\n        type\n      })\n    });\n\n    if (middlewareData?.arrow) {\n      const {\n        x: arrowX,\n        y: arrowY\n      } = middlewareData.arrow;\n      Object.assign(arrowEl.style, {\n        left: arrowX != null ? `${arrowX}px` : \"\",\n        top: arrowY != null ? `${arrowY}px` : \"\"\n      });\n    }\n\n    const referenceHidden = middlewareData?.hide?.referenceHidden;\n    const visibility = referenceHidden ? \"hidden\" : null;\n    const pointerEvents = visibility ? \"none\" : null;\n    floatingEl.setAttribute(placementDataAttribute, effectivePlacement);\n    const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n    Object.assign(floatingEl.style, {\n      visibility,\n      pointerEvents,\n      position,\n      top: \"0\",\n      left: \"0\",\n      transform\n    });\n  });\n  return _positionFloatingUI.apply(this, arguments);\n}\n\nconst cleanupMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\n\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  const position = component.overlayPositioning; // ensure position matches for initial positioning\n\n  Object.assign(floatingEl.style, {\n    visibility: \"hidden\",\n    pointerEvents: \"none\",\n    position\n  });\n\n  if (position === \"absolute\") {\n    resetPosition(floatingEl);\n  }\n\n  const runAutoUpdate = Build.isBrowser ? autoUpdate : (_refEl, _floatingEl, updateCallback) => {\n    updateCallback();\n    return () => {\n      /* noop */\n    };\n  };\n  cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\n\n\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n\n  getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  const cleanup = cleanupMap.get(component);\n\n  if (cleanup) {\n    cleanup();\n  }\n\n  cleanupMap.delete(component);\n}\n\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\n\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n/**\n * This utils applies floating element styles to avoid affecting layout when closed.\n *\n * This should be called when the closing transition will start.\n *\n * @param floatingEl\n */\n\nfunction updateAfterClose(floatingEl) {\n  if (!floatingEl || floatingEl.style.position !== \"absolute\") {\n    return;\n  }\n\n  getTransitionTarget(floatingEl).addEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n}\n\nfunction getTransitionTarget(floatingEl) {\n  // assumes floatingEl w/ shadowRoot is a FloatingUIComponent\n  return floatingEl.shadowRoot || floatingEl;\n}\n\nfunction handleTransitionElTransitionEnd(event) {\n  const floatingTransitionEl = event.target;\n\n  if ( // using any prop from floating-ui transition\n  event.propertyName === \"opacity\" && floatingTransitionEl.classList.contains(FloatingCSS.animation)) {\n    const floatingEl = getFloatingElFromTransitionTarget(floatingTransitionEl);\n    resetPosition(floatingEl);\n    getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  }\n}\n\nfunction resetPosition(floatingEl) {\n  // resets position to better match https://floating-ui.com/docs/computePosition#initial-layout\n  floatingEl.style.transform = \"\";\n  floatingEl.style.top = \"0\";\n  floatingEl.style.left = \"0\";\n}\n\nfunction getFloatingElFromTransitionTarget(floatingTransitionEl) {\n  return closestElementCrossShadowBoundary(floatingTransitionEl, `[${placementDataAttribute}]`);\n}\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, rectToClientRect as e, filterComputedPlacements as f, reposition as r, updateAfterClose as u };","map":{"version":3,"names":["Build","c","getElementDir","r","closestElementCrossShadowBoundary","d","debounce","getSide","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","side","isVertical","coords","computePosition$1","config","strategy","middleware","platform","validMiddleware","filter","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","initialPlacement","elements","expandPaddingObject","padding","top","right","bottom","left","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","altContext","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","min$1","Math","min","max$1","max","within","min$1$1","value","max$1$1","arrow","arrowDimensions","getDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","clientHeight","clientWidth","centerToReference","center","offset","shouldAddOffset","alignmentOffset","centerOffset","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","alignment","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","sides","allPlacements","reduce","acc","concat","getPlacementList","autoAlignment","allowedPlacements","allowedPlacementsSortedByAlignment","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_placementsSortedByLe","detectOverflowOptions","placements","undefined","overflow","currentIndex","index","currentPlacement","currentOverflows","allOverflows","overflows","nextPlacement","placementsSortedByLeastOverflow","slice","sort","a","b","placementThatFitsOnAllSides","find","every","resetPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","isBasePlacement","overflowsData","push","_middlewareData$flip$","_middlewareData$flip2","nextIndex","_overflowsData$map$so","map","getSideOffsets","isAnySideFullyClipped","some","hide","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","getWindow","node","_node$ownerDocument","ownerDocument","defaultView","window","getComputedStyle$1","getComputedStyle","getNodeName","isNode","nodeName","toLowerCase","uaString","getUAString","uaData","navigator","userAgentData","Array","isArray","brands","item","brand","version","join","userAgent","isHTMLElement","HTMLElement","Element","Node","isShadowRoot","ShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","display","test","isTableElement","isContainingBlock","isFirefox","css","backdropFilter","WebkitBackdropFilter","transform","perspective","willChange","contain","isLayoutViewport","isLastTraversableNode","round","getCssDimensions","parseFloat","offsetWidth","offsetHeight","shouldFallback","fallback","unwrapElement","FALLBACK_SCALE","domElement","getBoundingClientRect","Number","isFinite","includeScale","isFixedStrategy","_win$visualViewport","_win$visualViewport2","clientRect","scale","win","addVisualOffsets","visualViewport","offsetLeft","offsetTop","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","document","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","getRectRelativeToOffsetParent","isOffsetParentAnElement","scroll","offsetRect","getParentNode","result","assignedSlot","parentNode","host","getTrueOffsetParent","position","getContainingBlock","currentNode","getViewportRect","html","layoutViewport","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getNearestOverflowAncestor","getOverflowAncestors","list","scrollableAncestor","isBody","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","getClippingElementAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","containingBlock","shouldDropCurrentNode","ancestor","set","elementClippingAncestors","_c","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getOffsetParentFn","getDimensionsFn","getClientRects","from","autoUpdate","update","ancestorScroll","_ancestorScroll","ancestorResize","elementResize","animationFrame","ancestors","forEach","addEventListener","passive","observer","initialUpdate","ResizeObserver","observe","frameId","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","_observer","removeEventListener","disconnect","cancelAnimationFrame","computePosition","Map","mergedOptions","platformWithCache","configOverrides","globalThis","floatingUINonChromiumPositioningFix","floatingUIBrowserCheck","patchFloatingUiForNonChromiumBrowsers","isBrowser","placementDataAttribute","repositionDebounceTimeout","effectivePlacements","defaultMenuPlacement","FloatingCSS","animation","animationActive","getMiddleware","flipDisabled","flipPlacements","offsetDistance","offsetSkidding","arrowEl","type","defaultMiddleware","filterComputedPlacements","filteredPlacements","console","warn","tagName","trim","getEffectivePlacement","floatingEl","reverse","reposition","component","delayed","open","debouncedReposition","positionFloatingUI","leading","maxWait","referenceEl","overlayPositioning","includeArrow","effectivePlacement","arrowX","arrowY","Object","assign","style","visibility","pointerEvents","setAttribute","cleanupMap","WeakMap","connectFloatingUI","disconnectFloatingUI","resetPosition","runAutoUpdate","_refEl","_floatingEl","updateCallback","getTransitionTarget","handleTransitionElTransitionEnd","cleanup","delete","visiblePointerSize","defaultOffsetDistance","ceil","hypot","updateAfterClose","shadowRoot","event","floatingTransitionEl","target","propertyName","classList","contains","getFloatingElFromTransitionTarget","F","e","f","u"],"sources":["C:/Users/akaps/Documents/Visual Studio 2022/Projects/MT_LRS/WebPresentation/node_modules/@esri/calcite-components/dist/components/floating-ui.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.7\n */\nimport { Build } from '@stencil/core/internal/client/index.js';\nimport { c as getElementDir, r as closestElementCrossShadowBoundary } from './dom.js';\nimport { d as debounce } from './debounce.js';\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        let resetPlacement = 'bottom';\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n              if (placement) {\n                resetPlacement = placement;\n              }\n              break;\n            }\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(middlewareArguments) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = middlewareArguments;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(\n  // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n  // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const offsetWidth = element.offsetWidth;\n  const offsetHeight = element.offsetHeight;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node\n  node.assignedSlot ||\n  // DOM Element detected\n  node.parentNode || (\n  // ShadowRoot detected\n  isShadowRoot(node) ? node.host : null) ||\n  // Fallback\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    // This doesn't appear to need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n  }\n\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\n// Returns the inner client rect, subtracting scrollbars if present\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  if (clippingAncestor === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingAncestor)) {\n    return getInnerBoundingClientRect(clippingAncestor, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\n/**\n * This module helps users provide custom configuration for component internals.\n *\n * @internal\n */\nconst configOverrides = globalThis[\"calciteComponentsConfig\"];\nconst config = {\n  /**\n   * We apply a custom fix to improve positioning for non-Chromium browsers.\n   * The fix comes at a performance cost, so provides users a way to opt-out if necessary.\n   *\n   * @internal\n   */\n  floatingUINonChromiumPositioningFix: true,\n  ...configOverrides\n};\n\nconst floatingUIBrowserCheck = patchFloatingUiForNonChromiumBrowsers();\nasync function patchFloatingUiForNonChromiumBrowsers() {\n  function getUAString() {\n    const uaData = navigator.userAgentData;\n    if (uaData?.brands) {\n      return uaData.brands.map((item) => `${item.brand}/${item.version}`).join(\" \");\n    }\n    return navigator.userAgent;\n  }\n  if (Build.isBrowser &&\n    config.floatingUINonChromiumPositioningFix &&\n    // ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\n    /firefox|safari/i.test(getUAString())) {\n    const { getClippingRect, getElementRects, getOffsetParent } = await import('./nonChromiumPlatformUtils.js');\n    platform.getClippingRect = getClippingRect;\n    platform.getOffsetParent = getOffsetParent;\n    platform.getElementRects = getElementRects;\n  }\n}\n/**\n * Exported for testing purposes only\n */\nconst placementDataAttribute = \"data-placement\";\n/**\n * Exported for testing purposes only\n */\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\n  \"top\",\n  \"bottom\",\n  \"right\",\n  \"left\",\n  \"top-start\",\n  \"top-end\",\n  \"bottom-start\",\n  \"bottom-end\",\n  \"right-start\",\n  \"right-end\",\n  \"left-start\",\n  \"left-end\"\n];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\"\n};\nfunction getMiddleware({ placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type }) {\n  const defaultMiddleware = [shift(), hide()];\n  if (type === \"menu\") {\n    return [\n      ...defaultMiddleware,\n      flip({\n        fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"]\n      })\n    ];\n  }\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [\n      ...defaultMiddleware,\n      offset({\n        mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n        crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0\n      })\n    ];\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({ alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null }));\n    }\n    else if (!flipDisabled) {\n      middleware.push(flip(flipPlacements ? { fallbackPlacements: flipPlacements } : {}));\n    }\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl\n      }));\n    }\n    return middleware;\n  }\n  return [];\n}\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter((placement) => effectivePlacements.includes(placement));\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements\n      .map((placement) => `\"${placement}\"`)\n      .join(\", \")\n      .trim()}`, { el });\n  }\n  return filteredPlacements;\n}\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n  return placement.replace(/leading/gi, placements[0]).replace(/trailing/gi, placements[1]);\n}\n/**\n * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.\n *\n * Note: this is not needed for components that use `calcite-popover`.\n *\n * @param component\n * @param options\n * @param options.referenceEl\n * @param options.floatingEl\n * @param options.overlayPositioning\n * @param options.placement\n * @param options.flipDisabled\n * @param options.flipPlacements\n * @param options.offsetDistance\n * @param options.offsetSkidding\n * @param options.arrowEl\n * @param options.type\n * @param delayed\n */\nasync function reposition(component, options, delayed = false) {\n  if (!component.open) {\n    return;\n  }\n  return delayed ? debouncedReposition(options) : positionFloatingUI(options);\n}\nconst debouncedReposition = debounce(positionFloatingUI, repositionDebounceTimeout, {\n  leading: true,\n  maxWait: repositionDebounceTimeout\n});\n/**\n * Positions the floating element relative to the reference element.\n *\n * **Note:** exported for testing purposes only\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.flipDisabled\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n * @param root0.includeArrow\n */\nasync function positionFloatingUI({ referenceEl, floatingEl, overlayPositioning = \"absolute\", placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, includeArrow = false, arrowEl, type }) {\n  if (!referenceEl || !floatingEl || (includeArrow && !arrowEl)) {\n    return null;\n  }\n  await floatingUIBrowserCheck;\n  const { x, y, placement: effectivePlacement, strategy: position, middlewareData } = await computePosition(referenceEl, floatingEl, {\n    strategy: overlayPositioning,\n    placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\"\n      ? undefined\n      : getEffectivePlacement(floatingEl, placement),\n    middleware: getMiddleware({\n      placement,\n      flipDisabled,\n      flipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type\n    })\n  });\n  if (middlewareData?.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : \"\",\n      top: arrowY != null ? `${arrowY}px` : \"\"\n    });\n  }\n  const referenceHidden = middlewareData?.hide?.referenceHidden;\n  const visibility = referenceHidden ? \"hidden\" : null;\n  const pointerEvents = visibility ? \"none\" : null;\n  floatingEl.setAttribute(placementDataAttribute, effectivePlacement);\n  const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n  Object.assign(floatingEl.style, {\n    visibility,\n    pointerEvents,\n    position,\n    top: \"0\",\n    left: \"0\",\n    transform\n  });\n}\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nconst cleanupMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  const position = component.overlayPositioning;\n  // ensure position matches for initial positioning\n  Object.assign(floatingEl.style, {\n    visibility: \"hidden\",\n    pointerEvents: \"none\",\n    position\n  });\n  if (position === \"absolute\") {\n    resetPosition(floatingEl);\n  }\n  const runAutoUpdate = Build.isBrowser\n    ? autoUpdate\n    : (_refEl, _floatingEl, updateCallback) => {\n      updateCallback();\n      return () => {\n        /* noop */\n      };\n    };\n  cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component\n * @param referenceEl\n * @param floatingEl\n */\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  const cleanup = cleanupMap.get(component);\n  if (cleanup) {\n    cleanup();\n  }\n  cleanupMap.delete(component);\n}\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n/**\n * This utils applies floating element styles to avoid affecting layout when closed.\n *\n * This should be called when the closing transition will start.\n *\n * @param floatingEl\n */\nfunction updateAfterClose(floatingEl) {\n  if (!floatingEl || floatingEl.style.position !== \"absolute\") {\n    return;\n  }\n  getTransitionTarget(floatingEl).addEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n}\nfunction getTransitionTarget(floatingEl) {\n  // assumes floatingEl w/ shadowRoot is a FloatingUIComponent\n  return floatingEl.shadowRoot || floatingEl;\n}\nfunction handleTransitionElTransitionEnd(event) {\n  const floatingTransitionEl = event.target;\n  if (\n  // using any prop from floating-ui transition\n  event.propertyName === \"opacity\" &&\n    floatingTransitionEl.classList.contains(FloatingCSS.animation)) {\n    const floatingEl = getFloatingElFromTransitionTarget(floatingTransitionEl);\n    resetPosition(floatingEl);\n    getTransitionTarget(floatingEl).removeEventListener(\"transitionend\", handleTransitionElTransitionEnd);\n  }\n}\nfunction resetPosition(floatingEl) {\n  // resets position to better match https://floating-ui.com/docs/computePosition#initial-layout\n  floatingEl.style.transform = \"\";\n  floatingEl.style.top = \"0\";\n  floatingEl.style.left = \"0\";\n}\nfunction getFloatingElFromTransitionTarget(floatingTransitionEl) {\n  return closestElementCrossShadowBoundary(floatingTransitionEl, `[${placementDataAttribute}]`);\n}\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, rectToClientRect as e, filterComputedPlacements as f, reposition as r, updateAfterClose as u };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}